{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ViewPatterns #-}
module Clash.Cores.Floating.Xilinx.Internal
where

import Clash.Explicit.Prelude

import Clash.Annotations.Primitive

import Clash.Cores.Floating.Xilinx.TH

data FloatingConfig = FloatingConfig
  { floatingArchOpt :: !FloatingArchOpt
  , floatingDspUsage :: !FloatingDspUsage
  , floatingBMemUsage :: !Bool
  } deriving (Eq, Show)

data FloatingArchOpt
  = SpeedArch
  | LatencyArch
  deriving (Eq, Show)

data FloatingDspUsage
  = NoDspUsage
  | MediumDspUsage
  | FullDspUsage
  deriving (Eq, Show)

-- | NaN as generated by Xilinx
--
-- Quiet NaN, no payload, positive
xilinxNaN :: Float
xilinxNaN = unpack 0x7FC00000

conditionFloat
  :: Float
  -> Float
conditionFloat x
  | isNaN x          = xilinxNaN
  | isDenormalized x = if x > 0 then 0 else -0
  | otherwise        = x

conditionFloatF
  :: Functor f
  => f Float
  -> f Float
conditionFloatF = fmap conditionFloat

addFloat#
  :: forall d dom n
   . ( KnownDomain dom
     , KnownNat d
     )
  => FloatingConfig
  -> Clock dom
  -> Enable dom
  -> DSignal dom n Float
  -> DSignal dom n Float
  -> DSignal dom (n + d) Float
addFloat# !_ clk en (conditionFloatF -> x) (conditionFloatF -> y) =
  let d = delayI (deepErrorX "Initial values of addFloat undefined") en clk
  in d . conditionFloatF $ x + y
{-# NOINLINE addFloat# #-}
{-# ANN addFloat#
      (InlinePrimitive [VHDL] $ vhdlBinPrim
         "Clash.Cores.Floating.Xilinx.Internal.addFloat#"
         "addFloat"
         "Clash.Cores.Floating.Xilinx.BlackBoxes.addFloatTclTF"
      ) #-}
